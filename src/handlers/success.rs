use crate::{constants::DEFAULT_ENVIRONMENT, utils::prompts::TokenInfo};
use colored::*;

/// Enum to define different types of success events that can occur during token generation or verification.
#[derive(Debug)]
pub enum SuccessType {
    /// Represents the success of a token creation process with token details.
    TokenCreated(TokenInfo, String),

    /// Represents the success of a token verification process, which could be from a path or URL.
    TokenVerified {
        /// Optional path where the token was verified.
        path: Option<String>,

        /// Optional URL where the token was verified.
        url: Option<String>,

        /// Optional address where the token was verified.
        address: Option<String>,

        /// Optional environment where the token was deployed.
        environment: Option<String>,

        /// Optional verified file name.
        file_name: Option<String>,
    },
}

/// Centralized success handler that formats and prints a success message based on the success type.
pub fn handle_success(success_type: SuccessType) {
    let success_prefix = "SUCCESS: ".green().bold();

    let message = match success_type {
        SuccessType::TokenCreated(token_info, message) => format!(
            "{}\nToken Details:\n  Name: {}\n  Symbol: {}\n  Decimals: {}\n  Description: {}\n  Frozen: {}\n  Environment: {}",
            message,
            token_info.name,
            token_info.symbol,
            token_info.decimals,
            token_info.description.if_empty("None"),
            token_info.is_frozen.to_yes_no(),
            token_info.environment
        ),

        SuccessType::TokenVerified {
            path,
            url,
            address,
            environment,
            file_name,
        } => {
            if let Some(addr) = address {
                format!(
                    "Verified: {} coin on {} was generated using the SUI Token Gen CLI.",
                    addr,
                    environment.unwrap_or_else(|| DEFAULT_ENVIRONMENT.to_string())
                )
            } else {
                let source = path.or(url.clone()).unwrap_or_default();
                let file_info = file_name.as_ref().map_or_else(
                    || format!("Verified successfully from: {}", source),
                    |file| {
                        // If URL exists, make the file name clickable, otherwise just show text
                        let clickable_file = url
                            .as_ref()
                            .map(|repo_url| format!(
                                "\x1b]8;;{}/blob/main/sources/{}\x1b\\{}\x1b]8;;\x1b\\",
                                repo_url, file, file
                            ))
                            .unwrap_or_else(|| file.clone());

                        format!("Verified source file: {} from {}", clickable_file.blue(), source)
                    },
                );

                format!(
                    "{}\n{}{}",
                    file_info,
                    "Note: ".yellow(),
                    "This code is generated by this tool and remains unmodified. Verification ensures it matches the tool's output but may not fully align with the published module."
                )
            }
        }
    };

    println!("{}{}", success_prefix, message);
}

/// Utility extension for `String` to return a fallback value if empty.
trait IfEmpty {
    fn if_empty(&self, fallback: &str) -> String;
}

impl IfEmpty for String {
    fn if_empty(&self, fallback: &str) -> String {
        if self.is_empty() {
            fallback.to_string()
        } else {
            self.clone()
        }
    }
}

/// Utility extension for `bool` to return "Yes" or "No".
trait ToYesNo {
    fn to_yes_no(&self) -> &'static str;
}

impl ToYesNo for bool {
    fn to_yes_no(&self) -> &'static str {
        if *self {
            "Yes"
        } else {
            "No"
        }
    }
}
